import * as React from 'react';
import './{{Params.Entity.Name}}Form.css';
import { Grid, TextField, Typography, Button, CircularProgress } from '@material-ui/core';
import DeleteIcon from '@material-ui/icons/Delete';
import EditIcon from '@material-ui/icons/Edit';
import SaveIcon from '@material-ui/icons/Save';
import {{Params.Entity.Name}}, { Create{{Params.Entity.Name}} } from 'src/models/{{Params.Entity.Name}}';
import * as moment from 'moment';
import { connect } from 'react-redux';
import { bindActionCreators, Dispatch } from 'redux';
import * as Actions from 'src/modules/{{Params.Entity.Name | DeCapitalize}}/actions';
import { IRootState } from 'src/modules';
import RouteComponentProps  from 'src/routing/RouteComponentProps';

interface IProps extends RouteComponentProps {
	{{Params.Entity.Name | DeCapitalize}}: {{Params.Entity.Name }} | undefined
	isLoading: boolean
	isInvalid: boolean
	actions: any
}

interface IState {
    {{Params.Entity.Name | DeCapitalize}}: {{Params.Entity.Name}} | undefined
	editMode: boolean
}

class {{Params.Entity.Name}}Form extends React.Component<any,IState> {
	constructor(props: any) {
		super(props);
		let id = 0;
		if (this.props.match.params.id !== "new") {
			id = parseInt(this.props.match.params.id, 10);
		}
		moment();
        this.state = { 
			{{Params.Entity.Name | DeCapitalize}}: this.props.{{Params.Entity.Name | DeCapitalize}},
			editMode: id === 0
		};
    }

	public componentWillReceiveProps(props: IProps) {
		if (this.state.{{Params.Entity.Name | DeCapitalize}} !== props.{{Params.Entity.Name | DeCapitalize}}) {
			this.setState({ {{Params.Entity.Name | DeCapitalize}}: props.{{Params.Entity.Name | DeCapitalize}} });
		}
	}

	public componentWillMount() {
		if (this.props.match.params.id !== "new") {
			const {{Params.Entity.Name | DeCapitalize}} = this.props.{{Params.Entity.Name | DeCapitalize}};
			const id = parseInt(this.props.match.params.id, 10);
			if ({{Params.Entity.Name | DeCapitalize}} == null || id !== {{Params.Entity.Name | DeCapitalize}}.id) {
				this.props.actions.get{{Params.Entity.Name }}(id);
			}
		}
		else {
			this.setState({ {{Params.Entity.Name | DeCapitalize}}: Create{{Params.Entity.Name }}() })
		}
	}

    public render() {
		if (this.props.isLoading && !this.props.isInvalid) {
			return (<div className="loading-circle"><CircularProgress /></div>);
		}
		if (this.state.{{Params.Entity.Name | DeCapitalize}} == null) {
			return (
				<Typography variant="h4">
					{{Params.Entity.Name }} with id {this.props.match.params.id} does not exist.
				</Typography>
			);
		}
        return (
            <div>	
                <Grid container={true} spacing={24}>
					<Grid item={true} sm={12}>
						<Typography variant="h3">
							{{Params.Entity.Name}} { this.state.{{Params.Entity.Name | DeCapitalize}}.id === 0 ? "- Create New" : this.state.editMode ? "- Edit Mode" : ""}
						</Typography>
						{this.state.{{Params.Entity.Name | DeCapitalize }}.id !== 0 ?
							(
								<Typography variant="h6">
									Id: {this.state.{{Params.Entity.Name | DeCapitalize }}.id}
								</Typography>
							)
							: ""
						}
					</Grid>
					<Grid item={true} sm={12}>
						{this.state.{{Params.Entity.Name | DeCapitalize}}.id !== 0 ?
							(
								<Button variant="contained" color="secondary" onClick={this.onDeleteClick}>
									Delete
        							<DeleteIcon />
								</Button>
							)
							: ""
						}
						{!this.state.editMode ?
							(
							{%- raw -%}
								<Button variant="contained" color="primary" style={{ marginLeft: 10 }} onClick={this.toggleMode}>
									Edit
        							<EditIcon />
								</Button>
							)
							: (
								<Button variant="contained" color="primary" style={{ marginLeft: 10 }} onClick={this.onSaveClick}>
									Save
        							<SaveIcon />
								</Button>
							{%- endraw -%}
							)
						}
					</Grid>
				{%- for field in Params.Entity.Fields -%}
					{%- if field.Type.IsSimpleType -%}
						{%- unless field.Name == 'id' -%}
                    <Grid item={true} xs={12} sm={6}>
							{%- if field.Type.Name == 'boolean' -%}
								<FormControlLabel
									label="{{ field.Name | SplitCamelCase }}"
									control={
										<Checkbox
											id="{{ field.Name | DeCapitalize }}"
											checked={this.state.{{Params.Entity.Name | DeCapitalize }}.{{ field.Name | DeCapitalize }}}
											onChange={this.on{{ field.Name }}Change}
											color="primary"
											disabled={!this.state.editMode}
										/>
									}
								/>
							{%- else -%}
						<TextField
						  required={true}
						  id="{{field.Name}}"
						  name="{{field.Name | Capitalize}}"
						  label="{{field.Name | Capitalize}}"
							{%- if field.Type.Name == 'number' -%}
						  type="{{ field.Type.Name }}"
							{%- elsif field.Type.Name == 'Date' -%}
						  type="datetime-local" 
							{%- endif -%}
						  fullWidth={true}
							{%- if field.Type.Name == 'Date' -%}
						  value = { moment(this.state.{{Params.Entity.Name | DeCapitalize}}.{{field.Name}}).format("YYYY-MM-DDTHH:mm") }
							{%- else -%}
						  value = { this.state.{{Params.Entity.Name | DeCapitalize}}.{{field.Name}} }
							{%- endif -%}
						  disabled={!this.state.editMode}
						  onChange={this.on{{ field.Name }}Change}
						/>
							{%- endif -%}
					</Grid>
						{%- endunless -%}
					{%- endif -%}
				{%- endfor -%}
				 </Grid>
			</div>
        );
    }

	{%- for field in Params.Entity.Fields -%}
		{%- if field.Type.IsSimpleType -%}
			{%- unless field.Name == 'id' -%}

	private on{{field.Name}}Change = (e: React.ChangeEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => {
		if (this.state.{{Params.Entity.Name | DeCapitalize}} != null) {
			{%- if field.Type.Name == 'number' -%}
			this.setState({ {{Params.Entity.Name | DeCapitalize}}: {...this.state.{{Params.Entity.Name | DeCapitalize}}, {{field.Name}}: parseInt(e.target.value, 10) }});
			{%- elsif field.Type.Name == 'Date' -%}
			this.setState({ {{Params.Entity.Name | DeCapitalize}}: {...this.state.{{Params.Entity.Name | DeCapitalize}}, {{field.Name}}: new Date(e.target.value) }});
			{%- elsif field.Type.Name == 'boolean' -%}
			this.setState({ {{Params.Entity.Name | DeCapitalize}}: {...this.state.{{Params.Entity.Name | DeCapitalize}}, {{field.Name}}: !this.state.{{Params.Entity.Name | DeCapitalize}}.{{field.Name}}}});
			{%- else -%}
			this.setState({ {{Params.Entity.Name | DeCapitalize}}: {...this.state.{{Params.Entity.Name | DeCapitalize}}, {{field.Name}}: e.target.value }});
			{%- endif -%}
		}
    }
			{%- endunless -%}
		{%- endif -%}
	{%- endfor -%}

	private toggleMode = () => this.setState({ editMode: !this.state.editMode });

	private onSaveClick = () => {
		if (this.state.{{Params.Entity.Name | DeCapitalize}} == null) {
			throw new Error("Save could not be done for empty item.")
		}
		this.setState({ editMode: !this.state.editMode });

		if (this.state.{{Params.Entity.Name | DeCapitalize}}.id === 0) {
			this.props.actions.add{{Params.Entity.Name }}(this.state.{{Params.Entity.Name | DeCapitalize}});
		}
		else {
			this.props.actions.update{{Params.Entity.Name }}(this.state.{{Params.Entity.Name | DeCapitalize}}.id, this.state.{{Params.Entity.Name | DeCapitalize}});
		}
	}

	private onDeleteClick = () => {
		if (this.state.{{Params.Entity.Name | DeCapitalize}} == null) {
			throw new Error("Delete could not be done for empty item.");
		}
		this.setState({ editMode: !this.state.editMode });
		this.props.actions.delete{{Params.Entity.Name }}(this.state.{{Params.Entity.Name | DeCapitalize}}.id);
	}
}
const mapStateToProps = (state: IRootState) => {
	return {
		{{Params.Entity.Name | DeCapitalize}}: state.{{Params.Entity.Name | DeCapitalize}}.{{Params.Entity.Name | DeCapitalize}},
		isLoading: state.{{Params.Entity.Name | DeCapitalize}}.isFetching,
		isInvalid: state.{{Params.Entity.Name | DeCapitalize}}.isInvalid
	};
};

const mapDispatchToProps = (dispatch: Dispatch) => ({
	actions: bindActionCreators(Actions, dispatch),
});

export default connect(mapStateToProps, mapDispatchToProps)({{Params.Entity.Name}}Form);